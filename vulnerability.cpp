#include "vulnerability.h"

#include <boost/functional/hash.hpp>
#include <boost/random.hpp>
#include <boost/random/random_device.hpp>
#include <ctime>

using boost::hash_combine;
using boost::hash_value;

Vulnerability::Vulnerability(unsigned int ID) : m_ID(ID) {
  m_reqPriveleges = 0x00001;
  m_accPriveleges = 0x10000;
  m_componentType = 0;
  m_interfaceType = 0;
  m_description = "Empty";
  m_exploitVal = 1.0;

  m_integrity = false;
  m_availability = false;
  m_confidentiality = false;
  m_authentication = false;
  m_authorization = false;
}

Vulnerability::Vulnerability(std::string ID) {
  std::size_t id = 0;
  m_reqPriveleges = 1;
  m_accPriveleges = 5;
  m_componentType = 0;
  m_interfaceType = 0;
  m_description = "Empty";
  m_exploitVal = 1.0;

  m_integrity = false;
  m_availability = false;
  m_confidentiality = false;
  m_authentication = false;
  m_authorization = false;

  // generate unique id
  hash_combine(id, hash_value(ID));

  m_ID = id;
}

Vulnerability::Vulnerability(unsigned short reqPriveleges,
                             unsigned short accPriveleges,
                             unsigned int componentType,
                             unsigned int relExploit)
    : m_reqPriveleges(reqPriveleges), m_accPriveleges(accPriveleges),
      m_componentType(componentType), m_relExploit(relExploit) {
  std::size_t id = 0;
  m_exploitVal = 1.0;

  m_integrity = false;
  m_availability = false;
  m_confidentiality = false;
  m_authentication = false;
  m_authorization = false;

  // generate unique id
  hash_combine(id, hash_value(m_componentType));
  hash_combine(id, hash_value(m_description));

  m_ID = id;
  m_description = "NA";
}

Vulnerability::Vulnerability(unsigned short reqPriveleges,
                             unsigned short accPriveleges,
                             unsigned int componentType,
                             unsigned int relExploit, float exploitVal,
                             bool integrity, bool availability,
                             bool confidentiality, bool authentication,
                             bool authorization)
    : m_reqPriveleges(reqPriveleges), m_accPriveleges(accPriveleges),
      m_componentType(componentType), m_relExploit(relExploit),
      m_exploitVal(exploitVal), m_integrity(integrity),
      m_availability(availability), m_confidentiality(confidentiality),
      m_authentication(authentication), m_authorization(authorization) {
  std::size_t id = 0;

  hash_combine(id, hash_value(m_componentType));
  hash_combine(id, hash_value(m_description));

  m_ID = id;
  m_description = "NA";
}

Vulnerability::Vulnerability(unsigned short reqPriveleges,
                             unsigned short accPriveleges,
                             unsigned int componentType,
                             std::string description, unsigned int relExploit)
    : m_reqPriveleges(reqPriveleges), m_accPriveleges(accPriveleges),
      m_componentType(componentType), m_description(description),
      m_relExploit(relExploit) {
  std::size_t id = 0;
  m_exploitVal = 1.0;

  m_integrity = false;
  m_availability = false;
  m_confidentiality = false;
  m_authentication = false;
  m_authorization = false;

  // generate unique id
  hash_combine(id, hash_value(m_componentType));
  hash_combine(id, hash_value(m_description));

  m_ID = id;
}

Vulnerability::Vulnerability(unsigned short reqPriveleges,
                             unsigned short accPriveleges,
                             unsigned int componentType,
                             std::string description, unsigned int relExploit,
                             float exploitVal)
    : m_reqPriveleges(reqPriveleges), m_accPriveleges(accPriveleges),
      m_componentType(componentType), m_description(description),
      m_relExploit(relExploit), m_exploitVal(exploitVal) {
  std::size_t id = 0;

  m_integrity = false;
  m_availability = false;
  m_confidentiality = false;
  m_authentication = false;
  m_authorization = false;

  // generate unique id
  hash_combine(id, hash_value(m_componentType));
  hash_combine(id, hash_value(m_description));

  m_ID = id;
}

Vulnerability::Vulnerability(unsigned int ID, unsigned short reqPriveleges,
                             unsigned short accPriveleges,
                             unsigned int componentType,
                             std::string description, unsigned int relExploit,
                             float exploitVal)
    : m_ID(ID), m_reqPriveleges(reqPriveleges), m_accPriveleges(accPriveleges),
      m_componentType(componentType), m_description(description),
      m_relExploit(relExploit), m_exploitVal(exploitVal) {}

Vulnerability::Vulnerability(unsigned int ID, unsigned short reqPriveleges,
                             unsigned short accPriveleges,
                             unsigned int componentType,
                             std::string description, unsigned int relExploit)
    : m_ID(ID), m_reqPriveleges(reqPriveleges), m_accPriveleges(accPriveleges),
      m_componentType(componentType), m_description(description),
      m_relExploit(relExploit) {
  m_exploitVal = 1.0;
}

/// <summary>Function maps vulnerabilities from the database to ee/architecture</summary>
/// <returns>Map of applicable vulnerabilies for each element in ee/architecture</returns>
void vulnerabilityMapper(
    std::unordered_map<unsigned int, Vulnerability> globalVulMap,
    std::string entryPoint, const diGraph &eeArchitecture,
    std::vector<std::pair<unsigned int, std::vector<Vulnerability>>>
        &vulMapping,
    std::unordered_map<unsigned int, std::string> componetClasses,
    std::map<std::string, std::string> &compInstance) {
  unsigned int ID = 0;
  unsigned int index = 0;
  unsigned int compType = 0;
  int i = 0;
  unsigned int vulCounter = 0;
  std::unordered_map<unsigned int, std::string>::iterator u_it;
  diGraph::vertex_descriptor srcG, dstG;

  std::unordered_map<diGraph::vertex_descriptor, std::vector<unsigned int>>
      computeUnitsInterfaces;

  // 1. Iterate over all edges(:=connections) and for each source and
  // destination component apply the vulnerabilities which fits to the compute
  // type of the component and the interface
  for (auto e_it : boost::make_iterator_range(edges(eeArchitecture))) {
    // get source and destination of each edge to create a mapping between
    // compute units and their interfaces
    std::vector<unsigned int> tempInterfaces;
    unsigned int connectionType = eeArchitecture[e_it].connectType;
    unsigned int srcName = e_it.m_source;
    unsigned int destName = e_it.m_target;

    // for source of the edge
    auto find_it = computeUnitsInterfaces.find(srcName);
    if (find_it == computeUnitsInterfaces.end()) {
      // if compute unit does not exists, then create a new entry in the map and
      // add the relevant interface
      if (connectionType == 2) {
        int l = 0;
      }
      tempInterfaces.push_back(connectionType);
      computeUnitsInterfaces.insert(std::make_pair(srcName, tempInterfaces));
    } else {
      // if compute unit already exists, then add new interfaces and update
      // interface list
      tempInterfaces = find_it->second;
      tempInterfaces.push_back(connectionType);
      find_it->second = tempInterfaces;
    }

    tempInterfaces.clear();

    // for destination of the edge
    auto find2_it = computeUnitsInterfaces.find(destName);
    if (find2_it == computeUnitsInterfaces.end()) {
      // if compute unit does not exists, then create a new entry in the map and
      // add the relevant interface
      tempInterfaces.push_back(connectionType);
      computeUnitsInterfaces.insert(std::make_pair(destName, tempInterfaces));
    } else {
      // if compute unit already exists, add new interfaces and update interface
      // list
      tempInterfaces = find2_it->second;
      tempInterfaces.push_back(connectionType);
      find2_it->second = tempInterfaces;
    }
  }

  // Map vulnerabilities to compute-components
  // For each component the relevant interfaces are mapped
  for (auto vd : boost::make_iterator_range(computeUnitsInterfaces)) {
    compType = eeArchitecture[vd.first].compType;
    ID = eeArchitecture[vd.first].vertexID;
    std::vector<Vulnerability> localVulMap;

    // gahter name and type of component for model checking afterwards
    u_it = componetClasses.find(compType);
    if (u_it == componetClasses.end()) {
      continue;
    }
    std::string strCompType = u_it->second;
    compInstance.insert(
        std::make_pair(eeArchitecture[vd.first].vertexName, strCompType));

    // allocation of suitable vulnerabilities for each compute component
    for (std::unordered_map<unsigned int, Vulnerability>::iterator it =
             globalVulMap.begin();
         it != globalVulMap.end(); it++) {
      // do not apply vulnerabilities that do not increase privileges
      if ((it->second.m_vulClass == 1) &&
          (it->second.m_reqPriveleges >= it->second.m_accPriveleges))
        continue;

      // only apply vulnerabilities that belongs to vulnerability class 1 or 4
      if ((it->second.m_vulClass == 1) || (it->second.m_vulClass == 4)) {
        // check all vulnerabilities if they applicable to the current component
        if (it->second.m_componentType == compType) {

          // check if interface also matches
          auto findInterface_it = std::find(vd.second.begin(), vd.second.end(),
                                            it->second.m_interfaceType);
          if (findInterface_it != vd.second.end()) {
            // vulnerabilities that jump from the component to a connection
            localVulMap.push_back(it->second);
            vulCounter++;
          } else if (it->second.m_vulClass == 1) {
            // vulnerabilities that increase the priveledges on the component
            localVulMap.push_back(it->second);
            vulCounter++;
          }
        }
      }
    }
    std::cout << "Compute unit " + eeArchitecture[vd.first].vertexName +
                     " owns "
              << localVulMap.size() << " vulnerabilities" << std::endl;

    auto vulMap = std::make_pair(ID, localVulMap);
    vulMapping.push_back(vulMap);
  }

  // Map vulnerabilities to connections
  for (auto ed : boost::make_iterator_range(edges(eeArchitecture))) {
    unsigned int conType = eeArchitecture[ed].connectType;
    ID = eeArchitecture[ed].edgeID;
    std::vector<Vulnerability> localVulMap;

    // get destination (compute unit) of current edge
    unsigned int compTypeDest = eeArchitecture[ed.m_target].compType;

    // gahter name and type of connection for model checking afterwards
    u_it = componetClasses.find(conType);
    if (u_it == componetClasses.end()) {
      continue;
    }
    std::string strConnectType = u_it->second;
    compInstance.insert(
        std::make_pair(eeArchitecture[ed].edgeName, strConnectType));

    // allocation of suitable vulnerabilities for each connection
    // (connection->connection, connection->component)
    for (std::unordered_map<unsigned int, Vulnerability>::iterator it =
             globalVulMap.begin();
         it != globalVulMap.end(); it++) {
      // do not apply vulnerabilities that do not increase privileges
      if (it->second.m_reqPriveleges >= it->second.m_accPriveleges)
        continue;

      // only apply vulnerabilities that do belongs to vulnerability class 2 or
      // 3
      if ((it->second.m_vulClass == 2) || (it->second.m_vulClass == 3)) {
        // check if vulnerability type 3 (connection->connection) is applicable
        // to the current connection
        if ((it->second.m_vulClass == 3) &&
            (it->second.m_interfaceType == conType)) {
          // remember suitable vulnerabilities
          localVulMap.push_back(it->second);
          vulCounter++;
        }

        // check if vulnerability type 2 (connection->component) is applicable
        // to the current connection
        if ((it->second.m_vulClass == 2) &&
            (it->second.m_interfaceType == conType) &&
            (it->second.m_componentType == compTypeDest)) {

          // remember suitable vulnerabilities
          localVulMap.push_back(it->second);
          vulCounter++;
        }
      }
    }
    std::cout << "Connection " + eeArchitecture[ed].edgeName + " owns "
              << localVulMap.size() << " vulnerabilities" << std::endl;

    auto vulMap = std::make_pair(ID, localVulMap);
    vulMapping.push_back(vulMap);
  }
}