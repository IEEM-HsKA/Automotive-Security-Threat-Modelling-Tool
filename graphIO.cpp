#include "graphIO.h"
#include "riskAssess.h"

/// <summary>Reads attack paths which were generated by ITS-Tools (counterexample)</summary>
/// <returns>Attack paths</returns> 
bool readAttackPaths(
    diGraph eeArchitecturetecture,
    std::unordered_map<unsigned int, std::string> uniqueElements,
    std::unordered_map<unsigned int, Vulnerability> globalVulMap,
    std::string entryPoint, diGraph &attackPaths, unsigned int &rootNode,
    std::vector<unsigned int> &endNodes) {

  boost::dynamic_properties dp(boost::ignore_other_properties);
  boost::graph_traits<graph_t>::degree_size_type INdegree, OUTdegree;
  graph_t::vertex_descriptor vert, srcG, dstG;
  // diGraph::vertex_descriptor srcV, dstV;
  diGraph::edge_descriptor edd;

  bool matchedSrcVertex = false;
  bool matchedDestVertex = false;
  // Entry point of the attacker
  QString qs = QString::fromLocal8Bit(entryPoint.c_str());
  QRegularExpression entryP(qs);
  // jump(Zahlen)_(Zahlen)
  QRegularExpression jump("jump(\\d+)_(\\d+)");
  // Component.vul_(Zahlen)
  QRegularExpression vuls("(\\w+).vul_(\\d+)");
  QRegularExpression attPos(",attpos=(\\d+)");
  QRegularExpressionMatch match1, match2, match3, match4, match5;

  graph_t tempG(0);
  diGraph attPath(0);

  dp.property("label", get(&Vertex::label, tempG));
  dp.property("label", get(&Edge::label, tempG));
  dp.property("node_id", get(&Vertex::ID, tempG));

  // use of memory mapping techniques
  boost::iostreams::mapped_file_source dot("work//AT_Graph_0.dot");
  bool status = read_graphviz(dot.data(), tempG, dp);

  dot.close();

  if (!status) {
    qDebug() << "Coud not read file!";
    return false;
  }

  // iterate over all edges and build sub graph for visualization and risk
  // assessment
  auto es = boost::edges(tempG);
  for (auto e_it = es.first; e_it != es.second; ++e_it) {
    // bool loop = true;
    srcG = boost::source(*e_it, tempG);
    dstG = boost::target(*e_it, tempG);

    matchedSrcVertex = false;
    matchedDestVertex = false;

    // get label of attackPaths graph
    std::string eLabel = tempG[*e_it].label;
    std::string srcVLabel = tempG[srcG].label;
    std::string dstVLabel = tempG[dstG].label;

    std::string srcVID = std::to_string(srcG);
    std::string dstVID = std::to_string(dstG);

    //------------------------------------------------------------------
    // Find root node of the graph -> node with zero in going edges
    INdegree = boost::in_degree(srcG, tempG);

    if (INdegree == 0) {
      rootNode = srcG;
    }

    INdegree = boost::in_degree(dstG, tempG);

    if (INdegree == 0) {
      rootNode = dstG;
    }

    // Find end nodes of the graph -> node with zero out going edges
    OUTdegree = boost::out_degree(srcG, tempG);

    if (OUTdegree == 0) {
      endNodes.push_back(srcG);
    }

    OUTdegree = boost::out_degree(dstG, tempG);

    if (OUTdegree == 0) {
      endNodes.push_back(dstG);
    }

    // copy edges of "simple" search graph to the more complex graph structure
    auto ed = boost::add_edge(srcG, dstG, 0, attackPaths);
    edd = boost::edge(boost::vertex(srcG, attackPaths),
                      boost::vertex(dstG, attackPaths), attackPaths)
              .first;

    attackPaths[srcG].vertexName =
        srcVID; 
    attackPaths[srcG].vertexID = srcG;

    attackPaths[dstG].vertexName =
        dstVID;
    attackPaths[dstG].vertexID = dstG;

    std::unordered_map<unsigned int, std::string>::iterator it;

    // initialize edge weights
    boost::put(boost::edge_weight_t(), attackPaths, ed.first, 1.0);

    if (srcG == rootNode) {
      attackPaths[srcG].vertexName = "StartOfAttack";
    }
    if (dstG == rootNode) {
      attackPaths[dstG].vertexName = "StartOfAttack";
    }

    // source vertex
    match3 = attPos.match(QString::fromStdString(srcVLabel));
    if (match3.hasMatch()) {
      unsigned int srcID = match3.captured(1).toUInt();
      it = uniqueElements.find(srcID);
      attackPaths[srcG].vertexName = it->second; 
      attackPaths[srcG].vertexID = srcG;
      matchedSrcVertex = true;
    }

    // destination vertex
    match3 = attPos.match(QString::fromStdString(dstVLabel));
    if (match3.hasMatch()) {
      unsigned int dstID = match3.captured(1).toUInt();
      it = uniqueElements.find(dstID);
      attackPaths[dstG].vertexName = it->second;
      dstVID;
      attackPaths[dstG].vertexID = dstG;
      matchedDestVertex = true;
    }

    // high level attack graph that shows the way of the attack but only for
    // components and communication links

    // get jump
    match1 = jump.match(QString::fromStdString(eLabel));
    if (match1.hasMatch()) {
      unsigned int src = match1.captured(1).toInt();
      unsigned int dst = match1.captured(2).toInt();

      boost::add_edge(src, dst, attPath);
      auto e = boost::edge(boost::vertex(src, attPath),
                           boost::vertex(dst, attPath), attPath)
                   .first;

      vert = boost::source(e, attPath);
      attPath[vert].vertexName = match1.captured(1).toLocal8Bit().constData();

      vert = boost::target(e, attPath);
      attPath[vert].vertexName = match1.captured(2).toLocal8Bit().constData();
    }

    // get vulnerability path
    match2 = vuls.match(QString::fromStdString(eLabel));
    if (match2.hasMatch()) {
      QString componentName = match2.captured(1);
      QString vulnerabilityID = match2.captured(2);
      std::string edgeLabel = match2.captured(2).toLocal8Bit().constData();
      float exploitScaled = 1.0;

      auto it = globalVulMap.find(vulnerabilityID.toUInt());
      if (it != globalVulMap.end()) {
        exploitScaled = ((it->second.m_exploitVal) / 3.9);
      } else {
        exploitScaled = 1.0;
      }

      boost::put(boost::edge_weight_t(), attackPaths, ed.first, exploitScaled);
      attackPaths[edd].edgeName = edgeLabel;
    }

    // catch the first nodes which belongs to the entry point
    if ((!matchedSrcVertex) && (srcG != rootNode)) {
      attackPaths[srcG].vertexName = entryPoint;
    }

    if ((!matchedDestVertex) && (dstG != rootNode)) {
      attackPaths[dstG].vertexName = entryPoint;
    }
  }

  // remove duplicates
  std::sort(endNodes.begin(), endNodes.end());
  auto last = std::unique(endNodes.begin(), endNodes.end());
  endNodes.erase(last, endNodes.end());

  boost::filesystem::ofstream outFile("work//SearchGraph.dot");
  boost::write_graphviz(outFile, attackPaths,
                        boost::make_label_writer(boost::get(
                            &graphProps::VertexProps::vertexName, attackPaths)),
                        boost::make_label_writer(
                            boost::get(boost::edge_weight_t(), attackPaths)));
  outFile.close();

  return status;
}

/// <summary>Gerates the risk report for the user</summary>
/// <returns>Attack paths with risk values</returns> 
void generateReport(
    std::vector<std::pair<double, AttackPath>> attackPathVector,
    diGraph searchGraph, bool transpose,
    std::unordered_map<unsigned int, Vulnerability> globalVulMap,
    std::string entryPoint, std::string threat, std::string hazard) {
  // unsigned int pos = 0;
  unsigned short count = 0;
  unsigned int index = 0;
  // std::string tmp;
  std::string saveSrc;
  boost::filesystem::ofstream outFile("report.csv");
  std::ostream_iterator<std::string> outputIterator(outFile);

  for (std::vector<std::pair<double, AttackPath>>::iterator it =
           attackPathVector.begin();
       it != attackPathVector.end(); ++it) {
    std::vector<std::string> attackString;
    std::string tempString;
    count = 1;
    index = 0;
    std::string exploitability =
        "Path exploitability for threat " + hazard +
        " is: " + boost::lexical_cast<std::string>(it->second.m_riskValue) +
        "| ";

    tempString = exploitability;
    attackString.push_back(tempString);

    for (std::vector<diGraph::vertex_descriptor>::iterator it2 =
             it->second.m_pathElements.begin();
         it2 != it->second.m_pathElements.end(); ++it2) {
      if (it2 != it->second.m_pathElements.end() - 1) {
        if (!it->second.m_pathEdges[index].empty()) {
          if (count == 1) {
            tempString = searchGraph[*it2].vertexName + "|";
            attackString.push_back(tempString);
            count = 0;
          } else {
            if (transpose) {
              tempString = "to " + searchGraph[*it2].vertexName;
            } else {
              tempString = "from " + searchGraph[*it2].vertexName;
            }

            attackString.push_back(tempString);
          }

          std::string vul = it->second.m_pathEdges[index];
          unsigned int vulHash = std::stoul(vul);
          auto vul_it = globalVulMap.find(vulHash);

          if (vul_it != globalVulMap.end()) {
            tempString = " with [" + vul_it->second.m_description + "] to ";
            attackString.push_back(tempString);
            count = 1;
          }
        }

        index++;

      } else {
        tempString = "From " + entryPoint;
        attackString.push_back(tempString);
      }
    }

    std::string attackStringConcat;
    if (transpose) {

      for (auto rit = std::rbegin(attackString); rit != std::rend(attackString);
           ++rit) {
        attackStringConcat = attackStringConcat + *rit;
      }

      // reverse string and move last string to the front
      attackString.push_back(exploitability);
      std::reverse(attackString.begin(), attackString.end());
      attackString.pop_back();

    } else {
      for (auto it = std::begin(attackString); it != std::end(attackString);
           ++it) {
        attackStringConcat = attackStringConcat + *it;
      }

      attackString.push_back(tempString);
    }
    attackString.push_back("\n");

    // check duplicates and remove them
    std::unordered_map<std::vector<std::string>, int,
                       container_hash<std::vector<std::string>>>
        duplicates;

    auto findDuplicates = duplicates.find(attackString);
    if (findDuplicates == duplicates.end()) {
      duplicates.insert(std::make_pair(attackString, index));
      std::copy(attackString.begin(), attackString.end(), outputIterator);
    } else {
      //
    }
  }
  outFile.close();
}

/// <summary>Gerates the risk report for the user</summary>
/// <returns>Attack paths with risk values</returns>
void generateReport(
    std::vector<std::pair<double, AttackPath>> attackPathVector,
    diGraph searchGraph, bool transpose,
    std::unordered_map<unsigned int, Vulnerability> globalVulMap,
    std::string entryPoint, std::string threat, std::string hazard,
    std::vector<std::pair<std::string, std::string>> &strAttackPaths) {
  unsigned short count = 0;
  unsigned int index = 0;

  for (std::vector<std::pair<double, AttackPath>>::iterator it =
           attackPathVector.begin();
       it != attackPathVector.end(); ++it) {
    std::pair<std::string, std::string> tempResult;
    std::vector<std::string> attackString;
    std::string tempString;
    count = 1;
    index = 0;

    for (std::vector<diGraph::vertex_descriptor>::iterator it2 =
             it->second.m_pathElements.begin();
         it2 != it->second.m_pathElements.end(); ++it2) {
      if (it2 != it->second.m_pathElements.end() - 1) {
        if (!it->second.m_pathEdges[index].empty()) {
          if (count == 1) {
            tempString = searchGraph[*it2].vertexName;
            attackString.push_back(tempString);
            count = 0;
          } else {
            if (transpose) {
              tempString = "to " + searchGraph[*it2].vertexName;
            } else {
              tempString = "from " + searchGraph[*it2].vertexName;
            }

            attackString.push_back(tempString);
          }

          std::string vul = it->second.m_pathEdges[index];
          unsigned int vulHash = std::stoul(vul);
          auto vul_it = globalVulMap.find(vulHash);

          if (vul_it != globalVulMap.end()) {
            tempString = " with " + vul_it->second.m_description + " to ";
            attackString.push_back(tempString);
            count = 1;
          }
        }

        index++;

      } else {
        tempString = "From " + entryPoint;
        attackString.push_back(tempString);
      }
    }

    std::string attackStringConcat;
    if (transpose) {
      for (auto rit = std::rbegin(attackString); rit != std::rend(attackString);
           ++rit) {
        attackStringConcat = attackStringConcat + *rit;
      }

      tempResult = std::make_pair(
          boost::lexical_cast<std::string>(it->second.m_riskValue),
          attackStringConcat);

    } else {
      for (auto it = std::begin(attackString); it != std::end(attackString);
           ++it) {
        attackStringConcat = attackStringConcat + *it;
      }

      tempResult = std::make_pair(
          boost::lexical_cast<std::string>(it->second.m_riskValue),
          attackStringConcat);
    }

    strAttackPaths.push_back(tempResult);
  }
}

/// <summary>Check if expression is a number</summary>
/// <returns>True if expression is a number</returns>
bool isNumber(std::string token) {
  return std::regex_match(
      token, std::regex(("((\\+|-)?[[:digit:]]+)(\\.(([[:digit:]]+)?))?")));
}